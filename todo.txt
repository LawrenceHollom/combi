== FIXING EVERYTHING BROKEN IN THE BIG REFACTOR ==
- Maybe now is the ideal time to put those tests in?
- sink((size>0)&&(theta>=acyclic)) -> halts at n=15 fails (as a start)

== THE BIG REFACTOR ==
- Make everything more typeful. More typeful! Make a new branch.
-- Colour type?
-- Something for int_operation return type which needs only Ord.
- Remove all the 2.pow type things; use << instead.
- Move all flood fill to use Graph::flood_fill.
- Bunkbed optimise making the billions of EdgeSets so they can share indexers.
-- Change EdgeSet to take a reference to an indexer instead of an indexer?

== AUTOMATED TESTING ==
- Work out how to do it, and do it.
- Will be good for black-box testing when writing new stuff.
 
== THE KITCHEN SINK ==
- Maybe add option for increasing by number of edges or something
- test with sink((size>0)&&(theta>=acyclic)) -> halts at n=15
- Test fewer graphs for the very big n -> if more than 1000 then filter randomly
- Only run arrow commands on successful graphs (as in until)

== UNTIL ==
- Print out info about how many graphs made it past each step
- This way we could see e.g. how many triangle-free graphs we needed to check.
- Be more intelligent about cutting verbosity:
-- If threshold barely passed, then still print regular updates.

== PLANAR GIRTH CONSTRUCTOR ==
- k_gons is broken at the moment?
- Also need a way to plug this into a cubic-ifyer.

== BOWTIES ==
- Check that struct(bowties(d),num) agrees with old bowties framework
- Then rip out old framework.

== MIXED STRUCTURED GRAPH GENERATOR ==
- Take as input a graph with highlighted edges, each with one end of deg 1
- Either glue these edges together top-to-tail
- Or glue multiple deg-1 vertices together
- Imagined use case is regular graphs, so could deduce how many to glue
   from the degree.

== GRAPH IDENTIFIER ==
- Some tools to, given a graph (presumably from a file), try and identify it
- Simplest way is to run kitchen sink to try and ID it
- Could also identify vertex symmetric classes.
- See graph iterators below; this probably ties in well.

== DOMINATION ==
- Optimistic: either through construction or otherwise, notice when a graph has
  a small set of edges which split the graph into two parts. Then dp over these.
- Use case is probably cubic graphs, and sets of three edges (as graphs will be
  just barely 3-connected.)
- If done correctly then can compute domination numbers for very large graphs.

== FLOOD FILL ==
- Code up a generic flood fill algo; it comes up so much.
- Adding what stops the flood fill will be the difficult bit.
- This needs the generic edge framework for this to be feasible.

== HOUSE OF GRAPHS ==
- Have a new kitchen sink option for smashing through houseofgraphs
-- Work this in with the old one in some sensible way.

== ITERATOR ==
- Detect identical nodes in graphs and iterate over subsets more efficiently
- e.g. there are only 3 ways to pick 2 vertices from K_{s,t}

== BUNKBEDS ==
- The code is very (very) slow, and naive. Should be some wins to be had in terms of speed
- Instead of iterating through all subsets of edges, dfs:
-- Then once both endpoints are in, can cut off immediately.
-- Should speed things up a little.

== BUGS ==
- Maybe ->() has stopped working? Gets picked up as infix-like
- sink(domination>10) doesn't trip on E(11)

== HELP COMMAND ==
- Print all the various operations.
- And write code to do this automatically so it doesn't need maintaining.

== UNIT COMMANDS ==
- signature: prints out all kinds of info about the graph

== HOPELESSLY OPTIMISTIC INTERFACE GOALS ==
- Write up an interface in curses that allows for nicer printing of info
- Also could allow for better editing of commands, and command entry.
- Could have panels and all kinds of nice things
- Would want a new crate for curses interaction and all that stuff.
-- Is some of this already written somewhere?
- And you would spend like a week writing this for yourself because???

== KEEP CLIPPY HAPPY ==
- You don't want to anger clippy.